#! /usr/bin/env perl
use Getopt::Long;
use Cwd;
use Time::Local;
use strict;
use warnings;

my %monthnums = (
    1 => "Jan",
    2 => "Feb",
    3 => "Mar",
    4 => "Apr",
    5 => "May",
    6 => "Jun",
    7 => "Jul",
    8 => "Aug",
    9 => "Sep",
    10 => "Oct",
    11 => "Nov",
    12 => "Dec",
);

my $DEBUG = 0;
my $uniquename = "REPORT";

my ($help, $location, $kind, $env, $interval, $display, $project, $version, $softversion, $lastrun, $matchpattern, $shallow);

GetOptions
(
		'display' => \$display,
		'env=s' => \$env, #ENVVARS assumed and added to say run22744_8_5_2008
        'help' => \$help,
        'kind=s' => \$kind,
		'last' => \$lastrun,
		'shallow' => \$shallow,
		'match=s' => \$matchpattern, # if kind==whitelist then search in report for list matching this.
		'period=i' => \$interval,
		'outputdir=s' => \$location,
		'version=s' => \$version,
);

#DebugOn();

my @patternlist = ();
my $imagedir = "";
my $rundonestatus = 0;	# some runs remain in the checkprogress file toooooo long

# hmmmmm my bad. so far soar always writes the dag into movieruns.dag
# therefore dagman.out is here movieruns.dag.dagman.out and
# the rescue file if created is here movieruns.dag.rescue001


# we need to ask where certain things are now and NOT assume
# that everything is relative to TOPDIR. Any place referring
# to the top is likely broken as we now span multiple file systems
# with no conceived placement of any of the parts.
my $lookup = "";

if(defined $help) {
	help();
	exit(0);
}

if(!(defined $kind)) {
	$kind = "summary";
}

my $cwd = getcwd();
debug("We are here now....<<<$cwd>>>\n");
# we are either running a report in a run or from the control
# folder and this impacts which cp of Soar.pm we see during debug

# What kind of status are we interested in?
# print "Instructing this analysis <$kind>\n"; 

#print "Starting status check on $kind\n";


#
# these are the ones which are missing if not accounted for
# as we build the report cross check these so we can list those still
# running
#

#print "Report/profile for version <$version>\n";

#
# $location holds where the job folders are.

my @row;
my @list;

# we want a way to lookup and find all the tests which are still running
# so when we do a --kind=new, we only start new(not still running) jobs

my $reportfilename = "";
my $donefilename = "";

if($kind eq "summary") {
	$reportfilename = "report";
	open(REPORT,">$reportfilename") || die "Can not create report<$reportfilename>:$!\n";
	$donefilename = "done";
	open(DONE,">$donefilename") || die "Can not create done list<$donefilename>:$!\n";
	print "Report for this run is in <$reportfilename>\n";
}

my $firsttimestampforzerodata = "";
my $startstamp = 0;
my $stopstamp = 0;
my $duration;
if( !(defined $interval)) {
	$interval = 60 * 5; # lets try 5 minute pieces
}
my $buckets;
# End of year dilema
# condor user logs show no year and if one transtions from december to january
# we need to up the current year by one. Problem is with old dagman.out we had
# no year indicator. With new one we do so we can do good things incrementing 
# when dagman started year wise but will have a bad year transition for
# reports and plots with older dagman. Soar wants the newer dagman for splices
# and external subdags so we should avert the run started in december and ending
# in january into the future but must look for month transitions and adjust
# with every userlog duration calculation.

my $currentyear; # ASSUME its static during a run Save when we set duration
my $roughcurrentyear; # ASSUME its static during a run Save when we set duration

#if($kind eq "profile") {
	$duration = findDuration($location);
	debug( "findDuration returned $duration\n");
	$buckets = int($duration / $interval);
	debug( "Initial buckets is $buckets\n");
	$buckets++; 
	debug( "But need one more bin for the last partial period, so $buckets\n");
#}

#print "Bye\n";
#exit(0);
my @ready = ();			# initial scattering of submit events
my @alldone = ();			# initial scattering of terminate events
my @running = ();			# initial scattering of runs
my %seplogrunning = ();		# for complicated workflows, whats running now
my @timestamps = ();		# collection of time stamps
my @noresultfile = ();

#if($kind eq "profile") {
	# zero bins
	initBuckets(\@ready);
	initBuckets(\@alldone);
	initBuckets(\@running);
	initBuckets(\@timestamps);
#}

chdir($location);
#system("pwd;ls");
StoreSublogPatterns();
chdir($cwd);


my %resultcode;
my %resultstring;

my $resultcodekey = "RESULTVALUES";

if( $kind eq "summary") {
	parseRESULTVALUES();
}

chdir($location);
#print "In run location:\n";
my $topdir = getcwd();
#print "location is $topdir\n";
my $reporttime = `date`;
chomp($reporttime);
print "$kind Date:<$reporttime>\n";
#runcmd("ls");
chdir($cwd);

debug("just relocated to <$cwd> to find dag nodes\n");
my $mydagruns = FindDagNodes($location);
debug("just back  from find dag nodes\n");
my @dagruns = split ":",$mydagruns;

foreach my $run (@dagruns) {
	print "Found run $run\n";
}

# visit each run looking for various file attributes

# collect summary data
# We will have a list reference as the hash value
# for both failures and blacklist
my %failures = ();
my %successes = ();
my %blacklist = ();
my %jobbreakdown;

my @mydone = ();

#collect image size data
my %imageszdata;
my %imageszindata;
my %imagerundata;
my %imageruntotdata;
my %imagestarts;
my $done = "false";
my $csv = "dataanalysis.csv";


#DebugOn();

foreach my $dir (@dagruns) {
	chdir("$topdir"); # back to starting position
	chdir("$dir"); # go in and look
	debug("process job <$dir>\n");
	print "process job <$dir>\n";
	system("ls");
	my $line = "";
	if( $kind eq "profile" ) {
		# ************************ PROFILE ************************
		# examine user log and colect image size plus
		#print "Before profilelog ***************************************************** \n";
		profileLog();
		#print "After profilelog ***************************************************** \n";
	} elsif( $kind eq "summary" ) {
		# ************************ SUMMARY ************************
		#print " ************************ SUMMARY ************************ \n";
		my $didfail = 0;
		# read "RESULT" and check against meaning and string
		my $results = "RESULT";
		if(!(-f	"$results")) {
			#print "Run is missing key result file<<<$dir/$results>>>\n";
			$results = "RESULTS";
			#print "trying alternate $dir/$results\n";
			if(!(-f "$results")) {
			push @noresultfile, $dir;
			#push @{$failures{"running"}}, $dir;
			next;
			}
		}
#%resultcode;
#%resultstring;
		open(RES,"<$results") or 
			die "Failed to open file with result<RESULT>:$!\n";
		$line = 0;
		while(<RES>) {
			chomp;
			debug("$results:<$line>\n");
			$line = $_;
		}
		close(RES);
		if($resultcode{$line} eq "passed") {
			debug("Good result code == passed\n");		
			push @{$successes{$resultstring{$line}}}, $dir;
			push @mydone, $dir;
		} else {
			push @{$failures{$resultstring{$line}}}, $dir;
			debug("Bad	adding $dir to failures\n");
		}
	} else {
	}
	#print "$dir\n";
	chdir("$topdir"); # back to starting position
}
#populateBlacklist();

my $donecount = $#mydone + 1;
my $nodecount = $#dagruns + 1;

if( $kind eq "summary" ) {
	my $totgood  = $donecount;
	my $totbad = countFailures("quiet");
	my $totnoresults = countNoResults("quiet");

	chdir("$cwd");
	#my $totblack = countBlacklist("quiet");
	$done = $totgood + $totbad;

	#if ($done == 0) {
		#print "Done == 0 so exiting\n";
		#print REPORT "Number done 0 Number still running $nodecount :)\n";
		#close(REPORT);
		#exit;
	#}

	if ($nodecount == 0) {
		print "None to do so exiting\n";
		print REPORT "Number done 0 Number still running $nodecount :)\n";
		close(REPORT);
		exit;
	}

	my $percent;
	if ($done == 0) {
		$percent = $done;
	} else {
		$percent = ($totgood / $done) * 100;
	}
	my $missing = $nodecount - ( $totgood + $totbad + $totnoresults);
	my $currentresults = $done ;
	my $accumulatedcpuhours = ReturnCpuHours($location);

	print REPORT "\n================================================================\n";
	print REPORT " Final report for run $uniquename - $reporttime\n";
	#print REPORT " Project $project \n";
	if($rundonestatus != 0) {
		print REPORT " Run completion caused by error or removal. Final Report\n";
	}
	print REPORT "================================================================\n\n";
	
	print REPORT "\n================================================================\n";
	print REPORT " Accumulated Cpu Hours: $accumulatedcpuhours\n";
	print REPORT "================================================================\n\n";
	
	open(PR,"<PROFILE") or print "Can not open PROFILE file:$!\n";
    my $profileline = <PR>;
    close(PR);
    chomp($profileline);
    print "Profiles = <$profileline>\n";
    my @profile = split /,/, $profileline;
    my $profilecount = @profile;


	print REPORT "\n================================================================\n";
    print REPORT " Goodput/Badput Analysis: $profilecount log types\n";
    print REPORT "================================================================\n\n";

	

    my @goodputbadput = ();
    foreach my $logclass (@profile) {
        print REPORT "Logs: $logclass\n\n";
		if(defined $shallow) {
        	@goodputbadput = `condor_userlog -total $location/*$logclass*.log`;
		} else {
        	@goodputbadput = `condor_userlog -total $location/*/*$logclass*.log`;
		}
        foreach my $line (@goodputbadput) {
            if($line =~ /^Host\/Job.*$/) {
                print REPORT "$line";
            } elsif($line =~ /^Total.*$/) {
                print REPORT "$line\n";
            }
        }
    }

    print REPORT "\n================================================================\n";
    print REPORT " Summary Analysis: \n";
    print REPORT "================================================================\n\n";

	print REPORT "Num jobs: $nodecount\n";
	print REPORT "Num successful: $totgood\n";
	print REPORT "Num failed: $totbad\n";
	#print REPORT "Num blacklisted: $totblack\n";
	print REPORT "Percent successful: $percent\n";
	if($kind eq "profile") {
		print REPORT "Wall time used: $duration\n\n";
	}
	print REPORT "Num possibly running: $totnoresults\n";
	print REPORT "Num missing: $missing\n";
	
	print REPORT "\n================================================================\n";
	print REPORT " Breakdown by Result for run $uniquename\n";
	print REPORT "================================================================\n\n";

	print REPORT "Current Results: $currentresults\n";
	#####################
	countFailures("list");
	dropFailures();
	dropCategory( "Success", \@mydone);
	countBlacklist("list");
	dropBlacklist();
	countNoResults("list");
	dropNoResults();
	#####################
	#print REPORT "\n================================================================\n";
	#print REPORT " Result Breakdown by Job\n";
	#print REPORT "================================================================\n\n";

	print REPORT "Current Results: $currentresults\n";
	#dropJobBreakdown();
	dropDone();
	if(defined $display) {
		open(REPORT,"<$reportfilename") || die "Can not create report<$reportfilename>:$!\n";
		while(<REPORT>) {
			print "DISPLAY:$_";
		}
		close(REPORT);
	}
	if($missing != 0) {
		my %missing;
		foreach my $tmpdir (@dagruns) {
			$missing{$tmpdir} = 1; # mark all missing
		}
		foreach my $tmpjob ( keys %jobbreakdown) {
			$missing{$tmpjob} = 0; # take ones classified already off
		}
		print REPORT "\n================================================================\n";
		print REPORT " Result Breakdown of Missing Runs\n";
		print REPORT "================================================================\n\n";

		print REPORT "Missing Results: ($missing) \n";
		my $mycounter = 0;
		foreach my $tmpjob2 ( sort keys %missing) {
			print REPORT "$tmpjob2 ";
			$mycounter += 1;
			if(($mycounter % 10) == 0) {
				print REPORT "\n	";
			}
		}
	}
	close(REPORT);
	if($rundonestatus != 0) {
		#print "Run status <$rundonestatus> disctates cleanupdag\n";
		my $nowdir = getcwd();
		chdir("$location");
		#DropCleanupDag();
		chdir("$nowdir");
	} else {
		#print "Run status <$rundonestatus> disctates no cleanupdag\n";
	}

}

if( $kind eq "profile") {
	#print "Total ready buckets\n";
	totalBuckets(\@ready);
	#print "Total done buckets\n";
	totalBuckets(\@alldone);
	adjustReady();
	#dumpBuckets(\@running);
	readyTimestamps();
	#dumpBuckets(\@timestamps);
	dropPlotdata();
	dropAllPlotdata();
	dropPlot();
}


exit(0);

##########################################################
#
# storeRun will add an entry to whatever entries are
# already within that sub intervals of the active
# portions of this job. Execute to Evict and Execute to
# Job Terminated.
#
##########################################################

sub storeRun
{
	my $runstartstamp = shift;
	my $runstopstamp = shift;
	my $donenow = shift;
	my $logfile = shift;
	my $place;

	#DebugOn();
	if($runstartstamp == 0) {
		return{}; # something like immediate shadow exception
		# before execution started.
	}

	debug( "storeRun<start=$runstartstamp><Stop=$runstopstamp><donenow=$donenow>\n");
	debug( "interval<$interval>\n");

	my $accumulatedtime = ($runstopstamp - $runstartstamp);
	debug( "Accumulating <$accumulatedtime> seconds\n");

	if(($runstopstamp - $runstartstamp) < ($interval/2)){
		# duration has to be at least 1/2 interval to map
		# don't count fast evictions unless job completed
		if($donenow == 0) {
		debug( "Duration has to be at least 1/2 interval to map\n");
			return($accumulatedtime);
		}
	}
	debug( "runstartstamp = $runstartstamp startstamp = $startstamp interval = $interval\n");
	$place = int(($runstartstamp - $startstamp)/ $interval);
	if(!(defined $place)) {
		print "runstartstamp = $runstartstamp startstamp = $startstamp interval = $interval\n";
		print "\$place NOT defined.... see above .... ************************************\n";
	}
	debug( "Insert <$place>\n");
	#DebugOff();


	#DebugOn();
	#We will not break up the categories into more then elements then 
	#we had profile patterns declared for. So we test for it matching
	#a pattern and store on the subpattern it matches
	#@patternlist

	my $multilog = "";
	foreach my $name (@patternlist) {
		debug("Pattern for column <$name>\n");
		if($logfile =~ /^(.*?)$name(.*?)$/){
			# take first hit
			debug("$logfile categorized as <$1/$name/$2>\n");
			$multilog = $name;
			last;
		}
	}
	#DebugOff();

	#Have we started tracking this node yet?
	if(exists $seplogrunning{$multilog}) {
		debug("Already tracking <$multilog>\n");
	} else {
		debug("Starting tracking of <$multilog>\n");
		#$seplogrunning{$multilog} = (); # new array
		#initBuckets(\@{$seplogrunning{$multilog}});
	}
	$running[$place] = $running[$place] + 1;
	debug("Slot <$place> holds <@{$seplogrunning{$multilog}}[$place]>\n");
	@{$seplogrunning{$multilog}}[$place] = @{$seplogrunning{$multilog}}[$place] + 1;
	$runstartstamp = $runstartstamp + $interval;
	$place = $place + 1;
	while($runstartstamp < $runstopstamp) {
		debug( "Insert <$place>\n" );
		#print "\$place now<$place> element 0 in running<$running[0]>\n";
		$running[$place] = $running[$place] + 1;
		if($multilog ne "") {
			@{$seplogrunning{$multilog}}[$place] = @{$seplogrunning{$multilog}}[$place] + 1;
		}
		$runstartstamp = $runstartstamp + $interval;
		$place = $place + 1;
	}
	foreach my $bins (@{$seplogrunning{$multilog}}) {
		debug("$bins\n");
	}
	#DebugOff();
	# might be a little sloppy at the end point but
	# but close enough for a first tack.
	return($accumulatedtime);
}

##########################################################
#
# storeDone will add an entry to whatever entries are
# already within that sub interval of the overall job
# Later we will make this an accumulation of all the 
# runs which have previously ended with all the ones
# that end in the current interval.
#
##########################################################

sub storeDone
{
	my $donestamp = shift;
	#print "Done stamp <$donestamp>\n";
	#print "interval <$interval>\n";
	#print "Start STamp <$startstamp>\n";

	my $elapsed = ($donestamp - $startstamp);
	#print "Elapsed time is $elapsed\n";
	my $place = int($elapsed/ $interval);

	#print "Slot to use is <$place>\n";
	$alldone[$place] = $alldone[$place] + 1;
}

##########################################################
#
# storeReady will add an entry to whatever entries are
# already within that sub interval of the overall job
# Later we will make this an accumulation of all the 
# runs which have previously submitted with all the ones
# that are submitted in the current interval.
#
##########################################################

sub storeReady
{
	my $submitstamp = shift;
	#print "submit stamp <$submitstamp>\n";
	#print "interval <$interval>\n";
	#print "Start STamp <$startstamp>\n";
	my $elapsed = ($submitstamp - $startstamp);
	#print "Elapsed interval = $elapsed\n";
	my $place = int($elapsed/$interval);

	#my $place = int(($submitstamp - $startstamp)/ $interval);

	#print "Slot to use is <$place>\n";
	$ready[$place] = $ready[$place] + 1;
}

##########################################################
#
# adjustReady will calculate current ready for each interval
# by removing already completed job counts 
#
##########################################################

sub adjustReady
{
	my $slot = 0;
	while($slot < $buckets) {
		$ready[$slot] = ( $ready[$slot] -
			$alldone[$slot] );
		$slot = $slot + 1;
	}
	#dumpBuckets(\@ready);
}

sub ReturnCpuHours
{
	my $location = shift;
	my $currentloc = getcwd();
	#DebugOn();
	my $accumulatedseconds = 0;
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
	my $currentyear = $year; # save for later use

	chdir("$location");
	opendir DL, "\." or die "Can not open $location:$!\n";
	foreach my $file (readdir DL)
	{
		my $line = "";
		next if $file =~ /^\.\.?$/;
		#if($file =~ /^(\d+)$/) {
		if(-d $file) {
			#print "profile $file\n";
			chdir("$file");
			#$accumulatedseconds += profileLog($file,$currentyear);
			$accumulatedseconds += profileLog();
			debug( "Accumulated seconds now <$accumulatedseconds>\n");
			chdir("..");
		}
		
	}
	closedir(DL);
	chdir("$currentloc");

	#print "Total Seconds: $accumulatedseconds \n";
	my $totalhours = ($accumulatedseconds/(60 * 60));
	debug( "Total CPU hours = $totalhours\n");

	return($totalhours);
}

##########################################################
#
# profileLog gathers stats for the run plot
#
# The assumption here is that we are in the individual
# run nodes and that the project script which generates the 
# project specific dag insert write the pattern we need to 
# examine for 1 or more log files into the file above
# called PROFILE.
#
##########################################################

sub StoreSublogPatterns
{
	my $patternstring = "";
	#DebugOn();
	# find the pattern the log/logs are based on.
	open(PROF,"<../PROFILE") || die "Failed to find profile pattern:$!\n";
	while(<PROF>) {
		chomp;
		$patternstring = $_;
	}

	@patternlist = split /,/, $patternstring;

	foreach my $multilog (@patternlist) {
		$seplogrunning{$multilog} = (); # new array
		#print "Init of buckets for $multilog\n";
		initBuckets(\@{$seplogrunning{$multilog}});
	}
	debug("Pattern to determine profiling<$patternstring>\n");
	#DebugOff();
}

sub profileLog
{
	my $accumulatedtime = 0;
	my $lastmonth;
	my $usedyear = $currentyear;

#DebugOn();


	foreach my $pattern (@patternlist) {
		# open the directory and process any match assuming
		# the files are named pattern.*.log
		opendir(PL,".") || die "Failed to open . :$!\n";
		foreach my $file (readdir PL )
		{
			debug("consider<$file>\n");
			debug("pattern<$pattern>\n");
			if( $file =~ /^$pattern.*\.log$/ ) {
				 debug("process<$file>\n");
				 #print "status process of $file\n";
				# may not be submitted yet
				open(LOG,"<$file") || return(0);
				my $line = "";
				my $submitstamp;
				my $runningstamp = 0;
				my $donestamp;
				my $imageszstamp = 0;
				my $runopen = 0; # are we currently executing #3 below
				while(<LOG>) {
					chomp;
					$line = $_;
					#print "$line\n";
					# process submits
					# Job terminated events(0)
					# process executing on 3 ways
					#	1. paired with Job Terminated
					# 	2. paired with evicted
					#	3. Not paired collect run from strt -> last image update

					# Process Submit Event
					# NOTE: In all cases after the submit increment year if last month is larger!
					debug("Year now <$usedyear>\n");
					if( $line =~ /^000\s\(\d+\.\d+\.\d+\)\s+(\d+)\/(\d+)\s+(\d+):(\d+):(\d+)\s+Job\ssubmitted.*$/ ) {
						$lastmonth = $1;
						debug( "Submit at M $1 D $2 H $3 M $4 S $5 <$usedyear>\n");
						$submitstamp = timelocal($5,$4,$3,$2,($1 -1),$usedyear);
						storeReady($submitstamp);
					} elsif( $line =~ /^005\s\(\d+\.\d+\.\d+\)\s+(\d+)\/(\d+)\s+(\d+):(\d+):(\d+)\s+Job\sterminated.*$/ ) {
						debug( "\nDone at M $1 D $2 H $3 M $4 S $5\n");
						if($lastmonth > $1) {
							$usedyear += 1;
						}
						$lastmonth = $1;

						$runopen = 0;
						$donestamp = timelocal($5,$4,$3,$2,($1 -1),$usedyear);
						#debug( "With DONE donstamp is <$donestamp>\n");
						storeDone($donestamp);
						#print "Done\n";
						$accumulatedtime += storeRun($runningstamp,$donestamp,1,$file);
					} elsif( $line =~ /^001\s\(\d+\.\d+\.\d+\)\s+(\d+)\/(\d+)\s+(\d+):(\d+):(\d+)\s+Job\sexecuting.*$/ ) {
						debug( "Run at M $1 D $2 H $3 M $4 S $5\n");
						if($lastmonth > $1) {
							$usedyear += 1;
						}
						$lastmonth = $1;
						$runopen = 1;
						$runningstamp = timelocal($5,$4,$3,$2,($1 -1),$usedyear);
						debug( "Running stamp updated <$runningstamp>\n");
					} elsif( $line =~ /^004\s\(\d+\.\d+\.\d+\)\s+(\d+)\/(\d+)\s+(\d+):(\d+):(\d+)\s+Job\swas\sevicted.*$/ ) {
						debug( "Evict at M $1 D $2 H $3 M $4 S $5\n");
						if($lastmonth > $1) {
							$usedyear += 1;
						}
						$lastmonth = $1;
						$runopen = 0;
						$donestamp = timelocal($5,$4,$3,$2,($1 -1),$usedyear);
						#print "Evict\n";
						$accumulatedtime += storeRun($runningstamp,$donestamp,0,$file);
					} elsif( $line =~ /^007\s\(\d+\.\d+\.\d+\)\s+(\d+)\/(\d+)\s+(\d+):(\d+):(\d+)\s+Shadow\sexception.*$/ ) {
						debug( "Shadow Exception at M $1 D $2 H $3 M $4 S $5\n");
						if($lastmonth > $1) {
							$usedyear += 1;
						}
						$lastmonth = $1;
						$runopen = 0;
						$donestamp = timelocal($5,$4,$3,$2,($1 -1),$usedyear);
						if($runningstamp == 0) {
							# not running yet, ignore
						} else {
							#print "Exception\n";
							$accumulatedtime += storeRun($runningstamp,$donestamp,0,$file);
						}
					} elsif( $line =~ /^006\s\(\d+\.\d+\.\d+\)\s+(\d+)\/(\d+)\s+(\d+):(\d+):(\d+)\s+Image\s+size\s+of.*$/ ) {
						if($lastmonth > $1) {
							$usedyear += 1;
						}
						$lastmonth = $1;
						$imageszstamp = timelocal($5,$4,$3,$2,($1 -1),$usedyear);
						#print "Image size change <$imageszstamp>\n";
						#print "I";
					} elsif( $line =~ /^022\s\(\d+\.\d+\.\d+\)\s+(\d+)\/(\d+)\s+(\d+):(\d+):(\d+)\s+Job\s+disconnected.*$/ ) {
						if($lastmonth > $1) {
							$usedyear += 1;
						}
						$lastmonth = $1;
						$imageszstamp = timelocal($5,$4,$3,$2,($1 -1),$usedyear);
						#print "Disconnect <$imageszstamp>\n";
					} elsif( $line =~ /^023\s\(\d+\.\d+\.\d+\)\s+(\d+)\/(\d+)\s+(\d+):(\d+):(\d+)\s+Job\s+reconnected.*$/ ) {
						if($lastmonth > $1) {
							$usedyear += 1;
						}
						$lastmonth = $1;
						$imageszstamp = timelocal($5,$4,$3,$2,($1 -1),$usedyear);
						#print "Reconnect <$imageszstamp>\n";
					} else {
					}
				}
				if($runopen == 1){
					#handle #3 above
					#if($imageszstamp == 0) {
						$imageszstamp = timelocal(localtime());
					#}
					#print "Run open\n";
					$accumulatedtime += storeRun($runningstamp,$imageszstamp,0,$file);
				}
				close(LOG);
			} else {
				#debug("Do Not process<$file>\n");
				next;
			}
		}
	}
#DebugOff();
	return($accumulatedtime);
}
##########################################################
#
# readyTimestamps will calculate  a plotable time for
# each bucket 
#
# Also sometimes we don't see a zero point. And so the scale
# travels say between 1 and 2. This is a problem because
# during those times, a plot of 1 running and 1 ready shows
# nothing. So we want to calculate the time and timestamp
# for t -1 so we can drop a time, 0, 0 to plot.
#
# stash it here: $firsttimestampforzerodata
##########################################################

sub readyTimestamps
{
	my $slot = 0;
	my $stamp = 0;
	while($slot < $buckets) {
		$stamp = $startstamp + (($slot + 1) * $interval);
		my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($stamp);
		#print "H:M:S<$hour:$min:$sec>\n";
		$year = $year + 1900;
		if($sec < 10) { $sec = "0$sec" }
		if($min < 10) { $min = "0$min" }
		if($hour < 10) { $hour = "0$hour" }
		my $time = "$mday " . $monthnums{($mon + 1)} . " $year" . " $hour:$min:$sec GMT";
		$timestamps[$slot] = $time;
		$slot = $slot + 1;
	}
	#print "Start was $startstamp interval was $interval\n";
	# calculate a non-existent interval with no data yet to set scale from 0
	$stamp = $startstamp;
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($stamp);
	#print "H:M:S<$hour:$min:$sec>\n";
	$year = $year + 1900;
	if($sec < 10) { $sec = "0$sec" }
	if($min < 10) { $min = "0$min" }
	if($hour < 10) { $hour = "0$hour" }
	my $time = "$mday " . $monthnums{($mon + 1)} . " $year" . " $hour:$min:$sec GMT";
	$firsttimestampforzerodata = $time;
}

##########################################################
#
# dropPlotdata will create a plotable datafile called
#	$uniquename.data. 
#
##########################################################

sub dropPlotdata
{
	my $datafile = $uniquename . ".data";
	my $slot = 0;
	open(DATA,">$datafile") || die "Failed to open <$uniquename>: $!\n";
	#print "Buckets in dropPlotdata = $buckets\n";
	# drop initial zero data to set scale
	print DATA "$firsttimestampforzerodata, 0, 0\n";
	while($slot < $buckets) {
		#print ".";
		print DATA "$timestamps[$slot], $ready[$slot], $running[$slot]\n";
		$slot = $slot + 1;
		#last if( $ready[$slot] == 1);
	}
	close(DATA);
	print ".\n";
}

##########################################################
#
# dropAllPlotdata will create a plotable datafile called
#	$uniquename.all. 
#
##########################################################

sub dropAllPlotdata
{
	my $datafile = $uniquename . ".all";
	my $slot = 0;
	#DebugOn();
	open(DATA,">$datafile") || die "Failed to open <$uniquename>: $!\n";
	#print "Buckets in dropPlotdata = $buckets\n";
	# drop initial zero data to set scale
	print DATA "$firsttimestampforzerodata, 0, 0";
	foreach my $hashedarray (sort keys %seplogrunning) {
		debug("dropAllPlotdata: Hash element $hashedarray\n");
		print DATA ", 0";
	}
	print DATA "\n";

	while($slot < $buckets) {
		#print ".";
		print DATA "$timestamps[$slot], $ready[$slot], $running[$slot]";
		foreach my $hashedarray (sort keys %seplogrunning) {
			print DATA ", @{$seplogrunning{$hashedarray}}[$slot]";
		}
		print DATA "\n";
		$slot = $slot + 1;
		#last if( $ready[$slot] == 1);
	}
	close(DATA);
	print ".\n";
	#DebugOff();
}

##########################################################
#
# dropNoResults  will list entries which constitute runs
# still running or with unexpected termination.
#
##########################################################


sub dropNoResults
{
    my $reasons = keys %blacklist;
	my $runningfilename = "$location/$uniquename.running";
    print REPORT "=======================================\n";
    print REPORT "Running: ";
    my $counter = 0;
    foreach my $run (sort @noresultfile) {
        print REPORT "$run ";
        $counter++;
        if(($counter % 10) == 0) {
            print REPORT "\n    ";
        }
    }
    print REPORT "\n";
	#print "About to drop running file<$runningfilename>\n";
	#DropRunning($runningfilename, \@noresultfile);
}

##########################################################
#
# dropPlot will create a plot from the datafile called
#	$uniquename.data. 
#
##########################################################

sub dropPlot
{
	my $datafile = $uniquename . ".data";
	my $imagefile = $uniquename . ".png";
	my $datafileall = $uniquename . ".all";
	my $imagefileall = $uniquename . "_all" . ".png";
	print "*************************************************\n";
	print "Datafile <$datafile> Imagefile <$imagefile> Datafileall <$datafileall> Imagefileall <$imagefileall>\n";
	print "*************************************************\n";
	my $plottool = "$cwd/make-graphs";
	my $plotcmd =  "$plottool --input $datafile --output $imagefile";
	print "PLOTCMD: $plotcmd\n";
	print "*************************************************\n";
	my $plotcmdall =  "$plottool --input $datafileall --output $imagefileall --details ";
	my $line= "";
	open(DF,"<$datafileall") or die "Can not acces <$datafileall>:$!\n";
	$line = <DF>;
	chomp($line);
	my @fields = split /,/, $line;
	my $fieldcnt = @fields;
	print "Datafile has $fieldcnt fields\n";
	close(DF);
	#print "Plot command<$plotcmd>\n";
	#runcmd("pwd");
	runcmd("$plotcmd",{emit_output=>0});
	$plotcmdall = $plotcmdall . "$fieldcnt";
	MakeDataStack($datafileall, $fieldcnt);
	runcmd("$plotcmdall",{emit_output=>0});
}

##########################################################
#
#	gnuplot won't stack the results the way I want for
# 	the multi-phase plots. So will will ensure that the first
#   filed sticks up beyound all the others and repeat this
#   process such that the tallest peak will be bhind
#	the shorter ones etc.
#
# 	We are currently processing up to 5 phase
#
#	1 Feb 2012 12:11:03 GMT, 0, 0, 0, 0, 0, 0, 0
#	1 Feb 2012 12:16:03 GMT, 20, 25, 5, 20, 0, 0, 0
#	1 Feb 2012 12:21:03 GMT, 17, 19, 0, 19, 0, 0, 0
#	1 Feb 2012 12:26:03 GMT, 14, 15, 0, 13, 2, 0, 0
#	1 Feb 2012 12:31:03 GMT, 5, 11, 0, 10, 0, 1, 0
#	1 Feb 2012 12:36:03 GMT, 5, 7, 0, 5, 2, 0, 0
#	1 Feb 2012 12:41:03 GMT, 3, 8, 0, 2, 4, 2, 0
#	1 Feb 2012 12:46:03 GMT, 1, 2, 0, 1, 0, 1, 0
#	1 Feb 2012 12:51:03 GMT, 1, 2, 0, 0, 2, 0, 0
#	1 Feb 2012 12:56:03 GMT, 0, 1, 0, 0, 0, 1, 0
#	
#	1 Feb 2012 12:11:03 GMT, 0, 0, 0, 0, 0, 0, 0
#	1 Feb 2012 12:16:03 GMT, 20, 25, 25, 20, 0, 0, 0
#	1 Feb 2012 12:21:03 GMT, 17, 19, 0, 19, 0, 0, 0
#	1 Feb 2012 12:26:03 GMT, 14, 15, 0, 15, 2, 0, 0
#	1 Feb 2012 12:31:03 GMT, 5, 11, 0, 11, 0, 1, 0
#	1 Feb 2012 12:36:03 GMT, 5, 7, 0, 7, 2, 0, 0
#	1 Feb 2012 12:41:03 GMT, 3, 8, 0, 8, 6, 2, 0
#	1 Feb 2012 12:46:03 GMT, 1, 2, 0, 2, 0, 1, 0
#	1 Feb 2012 12:51:03 GMT, 1, 2, 0, 0, 2, 0, 0
#	1 Feb 2012 12:56:03 GMT, 0, 1, 0, 0, 0, 1, 0
#	
#
##########################################################

sub MakeDataStack
{
	my $datafile = shift;
	my $fieldcount = shift;
	my $newdata = "$datafile.new";

	my $new4 = 0;
	my $new5 = 0;
	my $new6 = 0;
	my $new7 = 0;
	my $new8 = 0;

	print "Adjusting <$datafile> with <$fieldcount> fields\n";
	# once we are skipping first 3 fields, if a value is non-zero
	# it gets the sum of values to it's right to it to ensure its
	# value pokes up above the following laying down of boxes.
	# process columns 4, 5, 6, 7, 8 assuming at least 5 columns.
	my $line = "";
	open(DF,"<$datafile") or die "Failed to open<$datafile>:$1\n";
	open(NDF,">$newdata") or die "Failed to open<$newdata>:$1\n";
	while(<DF>) {
		$new4 = 0;
		$new5 = 0;
		$new6 = 0;
		$new7 = 0;
		$new8 = 0;

		chomp();
		$line = $_;
		if($line =~ /^(.*?,\s*\d+,\s*\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+).*$/) {
			#print "$1, $2, $3, $4, $5, $6\n";
			$new4 = ($2 + $3 + $4 + $5 + $6);
			$new5 = ($3 + $4 + $5 + $6);
			$new6 = ($4 + $5 + $6);
			$new7 = ($5 + $6);
			$new8 = $6;
			print NDF "$1, $new4, $new5, $new6, $new7, $new8\n";
		} elsif($line =~ /^(.*?,\s*\d+,\s*\d+),\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d+).*$/) {
            #print "$1, $2, $3, $4, $5\n";
            $new4 = ($2 + $3 + $4 + $5);
            $new5 = ($3 + $4 + $5);
            $new6 = ($4 + $5);
            $new7 = ($5);
            print NDF "$1, $new4, $new5, $new6, $new7\n";
		} elsif($line =~ /^(.*?,\s*\d+,\s*\d+),\s*(\d+),\s*(\d+),\s*(\d+).*$/) {
            #print "$1, $2, $3, $4\n";
            $new4 = ($2 + $3 + $4);
            $new5 = ($3 + $4);
            $new6 = ($4);
            print NDF "$1, $new4, $new5, $new6\n";
		} elsif($line =~ /^(.*?,\s*\d+,\s*\d+),\s*(\d+),\s*(\d+).*$/) {
            #print "$1, $2, $3\n";
            $new4 = ($2 + $3);
            $new5 = ($3);
            print NDF "$1, $new4, $new5\n";
		}
	}
	close(DF);
	close(NDF);
	system("mv $datafile $datafile.old");
	system("mv $newdata $datafile");
}

##########################################################
#
# totalBuckets will calculate current done by adding data
# points from earlier intervals to the current interval. 
#
##########################################################

sub totalBuckets
{
	my $arrayref = shift;
	my $slot = 0;
	#print "totalBuckets: buckets=<$buckets>\n";
	while($slot < ($buckets - 1)) {
		#print "Slot=<$slot> Bucket=<$buckets>\n";
		${$arrayref}[($slot + 1)] = ( ${$arrayref}[($slot + 1)] +
			${$arrayref}[$slot] );
		$slot = $slot + 1;
	}
	#dumpBuckets($arrayref);
}

sub dumpBuckets
{
	my $arrayref = shift;
	my $slot = 0;
	while($slot < $buckets) {
		print "Slot  $slot:  ${$arrayref}[$slot]\n";
		$slot = $slot + 1;
	}
}

##########################################################
#
# initBuckets will zero each bucket in the array reference.
#
##########################################################

sub initBuckets
{
	my $arrayref = shift;
	my $slot = 0;
	while($slot < $buckets) {
		${$arrayref}[$slot] = 0;
		$slot = $slot + 1;
	}
}

##########################################################
#
# dropDone  will list the movies in order which
# have been processed with success or failure. However
# it will exclude failures due to incomplete movies
# allowing a run with --new to catch the movie if
# it ever is all there when doing other new data sets
#
##########################################################

sub dropDone
{
	my $line = "";
	#foreach my $job (sort { $a <=> $b } keys %jobbreakdown) {
	foreach my $job (sort { $a cmp $b } keys %jobbreakdown) {
		$line = $jobbreakdown{$job};
		if($line =~ /^.*Too\s+few\s+images.*$/) {
			print "$job not complete\n";
		} else {
			print DONE "$job\n";
		}
	}
	close(DONE);
}

##########################################################
#
# dropJobBreakdown  will list the movies in order with
# their individual status.
#
##########################################################

sub dropJobBreakdown
{
	#foreach my $job (sort { $a <=> $b } keys %jobbreakdown) {
	foreach my $job (sort { $a cmp $b } keys %jobbreakdown) {
		print REPORT "$job	$jobbreakdown{$job}\n";
	}
}

##########################################################
#
# dropFailures  will list entries which constitute  particular
# classes of failures.
#
##########################################################

sub dropFailures
{
	my $reasons = keys %failures;
	print REPORT "=======================================\n";
	foreach my $key (sort keys %failures) {
    	print REPORT "fail [$key]: ";
		my $counter = 0;
		my $size = $#{$failures{$key}} + 1;
    	foreach my $run (sort @{$failures{$key}}) {
        	print REPORT "$run ";
			$jobbreakdown{$run} = ": fail [$key]";
			$counter++;
			if(($counter % 10) == 0) {
				print REPORT "\n	";
			}
    	}
		print REPORT "\n\n";
	}
}

##########################################################
#
# countFailures  will return the total from all current 
# classes of failures.
#
##########################################################

sub countFailures
{
	my $mode = shift;
	my $reasons = keys %failures;
	my $totfailures = 0;
	if($mode eq "list") {
		print REPORT "\n=======================================\n";
		print REPORT "There are $reasons kinds of failures.\n";
	}
	foreach my $key (sort keys %failures) {
		my $size = $#{$failures{$key}} + 1;
		if($mode eq "list") {
			print REPORT "	For $key: $size\n";
		}
		$totfailures = $totfailures + $size;
	}
	return($totfailures);
}

##########################################################
#
# countNoResults  will return the total either still running
# or with unexpected failures.
#
##########################################################

sub countNoResults
{
	my $mode = shift;
	my $size = $#noresultfile + 1;
	if($mode eq "list") {
		print REPORT "\n=======================================\n";
		print REPORT "Still running: $size \n";
	}
	return($size);
}

##########################################################
#
# dropBlacklist  will list entries which constitute  particular
# type of blacklist.
#
##########################################################

sub dropBlacklist
{
	my $reasons = keys %blacklist;
	print REPORT "\n=======================================\n";
	foreach my $key (sort keys %blacklist) {
    	print REPORT "blacklisted [$key]: ";
		my $counter = 0;
		my $size = $#{$blacklist{$key}} + 1;
    	foreach my $run (sort @{$blacklist{$key}}) {
        	print REPORT "$run ";
			$jobbreakdown{$run} = ": blacklisted [$key]";
			$counter++;
			if(($counter % 10) == 0) {
				print REPORT "\n	";
			}
    	}
		print REPORT "\n";
	}
}

##########################################################
#
# countBlacklist  will return the total from all current 
# classes of blacklisting
#
##########################################################

sub countBlacklist
{
	my $mode = shift;
	my $reasons = keys %blacklist;
	my $totblacklist = 0;
	if($mode eq "list") {
		print REPORT "\n=======================================\n";
		print REPORT "There are $reasons kinds of blacklist.\n";
	}
	foreach my $key (sort keys %blacklist) {
		my $size = $#{$blacklist{$key}} + 1;
		if($mode eq "list") {
			print REPORT "	For $key: $size\n";
		}
		$totblacklist = $totblacklist + $size;
	}
	return($totblacklist);
}

##########################################################
#
# populateBlacklist  will compare blacklist runs to blacklist
# request information and fill in for our report.
#
##########################################################

sub populateBlacklist
{
	my $cwd = getcwd();
	my %blacklisted;
	chdir("$location");
	open(EFFECT,"<BLACKLISTED") || die "Can not find blacklisted file<BLACKLISTED:$!";
	while(<EFFECT>) {
		if($_ =~ /^(\d+)$/) {
			$blacklisted{"$1"} = 1;
			#print "Add $1\n";
		}
	}
	close(EFFECT);
	# Now find the reasons
	my $blackfile = "BLACKLIST";
	if(-f "$blackfile") {
    	open(NORUNS,"<$blackfile") || die "Can not open <$blackfile>: $!\n";
    	while(<NORUNS>) {
        	if($_ =~ /^(\d+)\s*:\s*blacklist\s*\[\s*(.*)\s*\].*$/) {
            	#print "Movie $1 blacklisted because: $2\n";
				if(exists $blacklisted{"$1"}) {
					push @{$blacklist{"$2"}}, $1;
				}
        	} else {
            	print "no match: $_";
        	}
    	}
	}

	chdir("$cwd");
}


##########################################################
#
# dropCategory will list entries which constitute a particular
# class of result.
#
##########################################################

sub dropCategory
{
	my $reasons = keys %successes;
	print REPORT "\n=======================================\n";
	print REPORT "=======================================\n";
	print REPORT "Completed successfully: $donecount\n";
	print REPORT "=======================================\n";
	foreach my $key (sort keys %successes) {
    	print REPORT "success [$key]: ";
		my $counter = 0;
		my $size = $#{$successes{$key}} + 1;
    	foreach my $run (sort @{$successes{$key}}) {
        	print REPORT "$run ";
			$jobbreakdown{$run} = ": worked [$key]";
			$counter++;
			if(($counter % 10) == 0) {
				print REPORT "\n	";
			}
    	}
		print REPORT "\n\n";
	}
}

##########################################################
#
# parseRESULTVALUES will read file which maps 
# the integer in the file RESULT to both either passed
# or faild AND a string to place in the report.
#
# format		value/passed or failed/Reason
#
##########################################################

sub parseRESULTVALUES
{
	open(FAILIN,"<$resultcodekey") || die "Can not open <$resultcodekey>:$!\n";
	my $line = "";
	my @keyvalues;

	while(<FAILIN>) {
		@keyvalues = ();
		chomp();
		$line = $_;
		# ignore blank lines
		next if($line =~ /^\s*$/);
		debug( "$line\n");
		@keyvalues = split /\//, $line;
		debug( "Value($keyvalues[0]), Meaning($keyvalues[1]), String($keyvalues[2])\n");
		$resultcode{$keyvalues[0]} = $keyvalues[1];
		$resultstring{$keyvalues[0]} = $keyvalues[2];
	}
}

##########################################################
#
# findDuration will calculate either the complete run
# of the Dag or current runtime.
#
# Note Dagman 7.5.1 added the year into its logs requiring
# double entries to determine duration in both the style
# with the 2 digit year and the style without.
#
##########################################################

sub findDuration
{
	my $location = shift;
	my $duration;
	my $lasttime;
	my $havestarttime = 0;
	my $startmonth;
	my $yeartouse = 0;
	my $finalyear = 0;
	my $dagout = $location . "/mydag.dag.dagman.out";
	#print "findDuration called ************* reset $startstamp *******************\n";
	unless (open(DAG,"<$dagout")) 
	{
		#print REPORT "No runs were made this time\n";
		#close(REPORT);
		die "Can not open <$dagout>: $!\n";
	}
	my $line = "";
	while(<DAG>) {
		chomp;
		$line = $_;
		#print "<<<<<$line>>>>>\n";

		my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
		$roughcurrentyear = $year; # save for later use

		if( $line =~ /^(\d+)\/(\d+)\s+(\d+):(\d+):(\d+)\s+\*\*\s+.*\(CONDOR_DAGMAN\)\sSTARTING\sUP$/ ) {
			#print "Old dagman start\n";
			if($havestarttime == 0) {
				$startmonth = $1;
				$yeartouse = $currentyear = $roughcurrentyear;
				$startstamp = timelocal($5,$4,$3,$2,($1 -1),$currentyear);
		#print "findDuration called ************* reset $startstamp *******************\n";
				#print "Startup:$line< $startstamp >\n";
				$havestarttime = 1;
			}
		} elsif( $line =~ /^(\d+)\/(\d+)\/(\d+)\s+(\d+):(\d+):(\d+)\s+\*\*\s+.*\(CONDOR_DAGMAN\)\sSTARTING\sUP$/ ) {
			#print "New dagman start<$line>\n";
			if($havestarttime == 0) {
				$startmonth = $1;
				$yeartouse = $currentyear = 100 + $3;
				$startstamp = timelocal($6,$5,$4,$2,($1 -1),$currentyear);
		#print "findDuration called ************* reset $startstamp YEAR <<<$currentyear>>> *******************\n";
				#print "Startup:$line< $startstamp >\n";
				$havestarttime = 1;
			}
		} elsif( $line =~ /^(\d+)\/(\d+)\s+(\d+):(\d+):(\d+)\s+\*\*\*\*\s+.*\(condor_DAGMAN\)\sEXITING\sWITH\sSTATUS\s(\d+)\s*$/ ) {
			#print "Old dagman run done\n";
			if(($1 < $startmonth) && ($finalyear == 0)) { # year rolled over
				$yeartouse += 1;
				$finalyear = 1;
			}
			$stopstamp = timelocal($5,$4,$3,$2,($1 -1),$yeartouse);
			#$stopstamp = timelocal($sec,$min,$hour,$mday,$mon,$year);
			$duration = ($stopstamp - $startstamp);
			#print "done:$line< $stopstamp :: $duration seconds >\n";
			$rundonestatus = $6;
			print "<$line> yielded status<$rundonestatus>\n";
			return($duration);
		} elsif( $line =~ /^(\d+)\/(\d+)\/(\d+)\s+(\d+):(\d+):(\d+)\s+\*\*\*\*\s+.*\(condor_DAGMAN\).*?EXITING\sWITH\sSTATUS\s(\d+)\s*$/ ) {
			if($7 != 3) {
				# make sure to ignore status of a dagman restart.......
				#print "New dagman run done\n";
				if(($1 < $startmonth) && ($finalyear == 0)) { # year rolled over
					$yeartouse += 1;
					$finalyear = 1;
				}
				$stopstamp = timelocal($6,$5,$4,$2,($1 -1),$yeartouse);
				#$stopstamp = timelocal($sec,$min,$hour,$mday,$mon,$year);
				$duration = ($stopstamp - $startstamp);
				#print "done:$line< $stopstamp :: $duration seconds >\n";
				$rundonestatus = $7;
				#print "<$line> yielded status<$rundonestatus> havestarttime<$havestarttime>\n";
				return($duration);
			} else {
				print "Seeing dagman restart\n";
			}
		} elsif( $line =~ /^(\d+)\/(\d+)\s+(\d+):(\d+):(\d+).*$/ ) {
			if($yeartouse != 0) {
				#print "Old last time\n";
				if(($1 < $startmonth) && ($finalyear == 0)) { # year rolled over
					$yeartouse += 1;
					$finalyear = 1;
				}
				#collect as late a time as we can for current state
				$lasttime = timelocal($5,$4,$3,$2,($1 -1),$yeartouse);
			}
		} elsif( $line =~ /^(\d+)\/(\d+)\/(\d+)\s+(\d+):(\d+):(\d+).*$/ ) {
			if($yeartouse != 0) {
				debug( "New last time\n");
				if(($1 < $startmonth) && ($finalyear == 0)) { # year rolled over
					$yeartouse += 1;
					$finalyear = 1;
				}
				#collect as late a time as we can for current state
				$lasttime = timelocal($6,$5,$4,$2,($1 -1),$yeartouse);
			}
		} else{
			# don't care about these.
		}
	}
	close(DAG);
	# if run not over, use last time stamp!
	if($stopstamp == 0) {
		debug("lasttime = <$lasttime>\n");
		$stopstamp = $lasttime;
		$duration = ($stopstamp - $startstamp);
		#print "done:$line< $stopstamp :: $duration seconds >\n";
		return($duration);
	}
}

#	sub sizeInputData
#	{
#		my $where = shift;
#		chdir("$where");
#		# what are the sizes of input data sets
#		open(DUSH,"du -sh * | ") ||
#			die "Could not collect sizes from $mydatasets: $!\n";
#		my $line = "";
#		while(<DUSH>) {
#			chomp;
#			$line = $_;
#			if($line =~ /^([\d\.]*)\s+(\d+).*$/) {
#				#print "$line\n";
#				$imageszindata{$2} = $1;
#			} elsif($line =~ /^([\d\.M]*)\s+(\d+).*$/) {
#				$imageszindata{$2} = $1 * 1024 * 1024;
#			} elsif($line =~ /^([\d\.K]*)\s+(\d+).*$/) {
#				$imageszindata{$2} = $1 * 1024 ;
#			} else {
#				#print "Unexpected format: $line\n";
#			}
#		}
#		close(DUSH);
#		chdir("$topdir");
#	}

sub by_order_big
{
    $imageszdata{$a} <=> $imageszdata{$b}
}

# =================================
# print help
# =================================

sub help
{
    print "Usage: mydag-status  --outputdir=xxxxx
        Options:
            [-h/--help]     See this
            [-k/--kind]     summary(report/default)

            \n";
}

# =================================
# print AddRowToList
# =================================

sub AddRowToList
{
	foreach my $item (@row) {
		#print "Adding to whitelist <$item>\n";
		chomp($item);
		next if($item =~ /^\s*$/);
		push @list, $item;
	}
}
 
sub debug
{
    my $string = shift;
    print( "DEBUG ", timestamp(), ": $string" ) if $DEBUG;
}

sub DebugOn
{
    $DEBUG = 1;
}

sub DebugOff
{
    $DEBUG = 0;
}

sub timestamp {
    return scalar localtime();
}

sub runcmd
{
	my $cmd = shift;
	system("$cmd");
}


#####################################################
#
# FindDagNodes returns a list of node runtime
# directories.
#
#####################################################

sub FindDagNodes
{
    my $location = shift;
	
	chdir("$location");

    debug("Looking for dag nodes here: $location\n");
	#system("pwd;ls");
	#print "Starting FindDagNodes ******************************************\n";

    opendir DH, "." or die "Can not open $location:$!\n";
    foreach my $file (readdir DH)
    {
        my $line = "";
        next if $file =~ /^\.\.?$/;
        #if($file =~ /^(\d+)$/) {
        if(-d "$file") {
			#print "$file\n";
        } else {
			#print "FindDagNodes: skip $file\n";
            next;
        }

        debug("$file\n");
        push @dagruns, $file;
    }
    push @dagruns, ".";
    closedir(DH);
	foreach my $dir (@dagruns) {
		print "NODE:$dir\n";
	}
    my $list = join ":", @dagruns;
	#print "Leaving FindDagNodes ******************************************\n";
    return($list);
}
